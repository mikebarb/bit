c
@startdatetokeep > DateTime.now - 365.days
DateTime.now - 365.days
DateTime.now
@startdatetokeep
q
Student.where(status: 'inactive').count
Student.where(id: linkedstudents.map{|o| o.student_id}).count
Student.where(status: 'inactive').where.not(id: linkedstudents.map{|o| o.student_id}).count
Student.where(status: 'inactive').where.not(id: linkedstudents.map{|o| o.student_id})
Student.count
Student.where(id: linkedstudents.map{|o| o.student_id}).count
Student.where.not(id: linkedstudents.map{|o| o.student_id}).count
Student.where.not(id: linkedstudents.map{|o| o.student_id})
Student.where(status: 'inactive').count
Student.where(status: 'inactive')
linkedstudents.map{|o| o.student_id}
linkedtutors.map{|o| o.tutor_id}
linkedtutors.map{|o| o.tutor_id
linkedtutors.count
linkedtutors
linkedtutorss
n
q
n
c
removestudents.count
n
removetutorss.count
removetutorss
n
linkedstudents.count
n
Tutor.count
Tutors.count
linkedtutors.count
linkedtutors
n
c
linkedtutors
n
q
n
q
Student.where.not(status: 'inactive').count
Student.not.where(status: 'inactive').count
Student.count
Student.where(status: 'inactive').count
Student.where(status: 'inactive').map{|o| print [o.id, o.pname, o.status].inspect + "\n"}
Student.where(status: 'inactive')
Student.where(status: inactive).count
Student.where(status: 'inactive').count
Student.where(status: 'inactive')
Tutrole.select(:tutor_id).uniq.count
Role.select(:student_id).uniq.count
Role.select(:id).uniq.count
Role.select(:id).uniq
c
n
q
removechanges.count
n
q
Change.count
Changs.count
Changes.count
    removechanges = Change.select(:id).where("created_at < :end_date", {end_date: @startdatetokeep}).count
    removechanges = Change.select(:id).where("created_at < :end_date", {end_date: @startdatetokeep}) 
    removechanges = Change.select(:id).where("timeslot < :end_date", {end_date: @startdatetokeep}) 
c
q
c
info b
info bb
c
dis b 1
info b 1
c
info b
c
dis b 1
c
Slot.where(first: 3564).map{|o| print [o.id, o.first, o.next].inspect + "\n"}
Slot.where(first: 3564).map{|o| print [o.id, o.first, o.next].inspect + '\n'}
Slot.where(first: 3564).map{|o| print [o.id, o.first, o.next}.inspect + '\n'}
n
slot
slots_to_update.map{|o| print [o.id, o.first, o.next].inspect + "\n"}
slot_to_update.map{|o| print [o.id, o.first, o.next].inspect + "\n"}
n
b 101
c
q
c
dis b 3
c
n
c
n
role_to_update_block
n
c
b 126
c
dis b 2
c
n
c
b 110
c
dis b 1
c
n
b 101
n
q
c
n
dis b 2
info b
c
dis b 1
n
mike.map{|o| print [o.id, o.block, o.first, o.next].inspect + "\n"}
mike = Role.where(first: role.first)
n
role_to_update_block.map{|o| print [o.id, o.block, o.first, o.next].inspect + "\n"}
role
n
role
n
role
n
role
role_to_update_block.map{|o| print [o.id, o.block, o.first, o.next].inspect + "\n"}
role_to_update_block
n
role
n
c
b 120
c
dis b 1
n
mike[0]
mike
mike = lessons_to_update = Lesson.where(first: lesson.first)
n
c
b 110
lessons_to_update
c
n
s
Lesson.where(first: lesson.first)
list=
help list
help
list
    end
      end
        end
          Role.where(first: role.first).update_all(first: role.id)
          role_to_update_first = Role.where(first: role.first)
          # this element id will become the first value for this segment
        if !flag_first_in_segment # not first element in segment
        #Role.where(block: role.block).update_all(block: role.id)
        role_to_update_block = Role.where(block: role.block)
        # this element id will become the block value for this block
        # No matter where it it broken, the block needs updating
      if !flag_first_in_block   # break chain, not first in block
      # if first element in block, then nothing to do.
      flag_first_segment    = role.first == role.block ? true : false
      flag_first_in_segment = role.id    == role.first ? true : false 
      flag_first_in_block   = role.id    == role.block ? true : false
    checkroles.each do |role|
    end
      end
        end
          Role.where(first: role.first).update_all(first: role.id)
          role_to_update_first = Role.where(first: role.first)
          # this element id will become the first value for this segment
        if !flag_first_in_segment # not first element in segment
        #Role.where(block: role.block).update_all(block: role.id)
        role_to_update_block = Role.where(block: role.block)
        # this element id will become the block value for this block
        # No matter where it it broken, the block needs updating
      if !flag_first_in_block   # break chain, not first in block
      # if first element in block, then nothing to do.
      flag_first_segment    = role.first == role.block ? true : false
      flag_first_in_segment = role.id    == role.first ? true : false 
      flag_first_in_block   = role.id    == role.block ? true : false
    checkroles.each do |role|
lesson
n
lessons_to_update
n
lesson
c
b 106
info b
ena b 1
c
q
c
dis b 3
c
n
tutrole
c
b 138
c
dis b 2
c
dis b 120
c
role
c
b 120
c
dis b 1
c
n
c
b 106
c
n
slot
n
q
n
q
checkslots.map{|o| print [o.id, o.first, o.next, o.wpo].inspect + "\n"}
checkslots.map{|o| print [o.id, o.first, o.next, o.wpo] + "\n"}
checkslots.map{|o| print [o.id, o.first, o.next, o.wpo]}
checkslots.map{|o| [o.id, o.first, o.next, o.wpo].inspect}
checkslots.map{|o| [o.id, o.first, o.next, o.wpo].inspect)
checkslots.map{|o| [o.id, o.first, o.next, o.wpo].inspect])
checkslots.count
checkslots
n
q
Slot.where.not(first: nil).first
Slot.where("timeslot > ? AND timeslot < ?", @checkdate.beginning_of_day, @checkdate.end_of_day).where(first: nil).count
Slot.where("timeslot > ? AND timeslot < ?", @checkdate.beginning_of_day, @checkdate.end_of_day).where(first: nil)
Slot.where("timeslot > ? AND timeslot < ?", @checkdate.beginning_of_day, @checkdate.end_of_day).where.not(first: nil)
Slot.where("timeslot > ? AND timeslot < ", @checkdate.beginning_of_day, @checkdate.end_of_day).where.not(first: nil)
Slot.where("timeslot > ? AND timeslot < ?", @checkdate.beginning_of_day, @checkdate.end_of_day)
Slot.where("timeslot < ? AND timeslot > ?", @checkdate.beginning_of_day, @checkdate.end_of_day)
Slot.where("timeslot < ?", @checkdate.beginning_of_day)
Slot.where("timeslot = :end_date", {end_date: @checkdate})
Slot.where(timeslot: @checkdate)
Slot.where(timeslot: :end_date, {end_date: @checkdate})
Slot.where("timeslot < :end_date", {end_date: @checkdate})
Slot.where("timeslot .eq. :end_date", {end_date: @checkdate})
Slot.where("timeslot eq :end_date", {end_date: @checkdate})
